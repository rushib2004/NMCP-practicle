"""Slove the following system of equation by Gauss Elimination Method: x+3y+2z=5 2x+4y-6z=-4

x+5y+3z=10

#Gaussian Elimination method N= 3

#function to get matrix content def gaussianElimination (mat):

# reduction into r.e.f. singular_flag forwardElim (mat)

#if matrix is singular if (singular_flag != -1): print("Singular Matrix.")

#if the RHS of equation corresponding to # zero roW is 0, system has infinitely # many solutions, else inconsistent*/ if (mat [singular_flag] [N]): print("Inconsistent System.")

else: print("May have infinitely many solutions.")

return

# get solution to system and print it using

# backward substitution

backSub(mat)

# function for elementary operation of swapping two rows def swap_row(mat, i, j):

fork in range(N + 1):

temp mat[i][k]

mat[i][k] = mat[j][k] mat[j][k] = temp

#function to reduce matrix to r.e.f.

def forwardElim(mat):

fork in range(N):

# Initialize maximum value and index for pivot imax = k v_max mat[i_max] [k]

for i in range(k + 1, N):

i_max = i

# find greater amplitude for pivot if any. if (abs(mat[i][k]) > v_max): v_max mat[i][k]

# if a principal diagonal element is zero,

# it denotes that matrix is singular, and

# will lead to a division-by-zero later.

if not mat[k][i_max]:

return k # Matrix is singular
#Swap the greatest value row with current row if (i max ! k): swap_row(mat, k, i_max)

for i in range(k+ 1, N):

#factor f to set current row kth element to 0,

# and subsequently remaining kth column to 0/ fmat[i][k]/mat[k][k]

#subtract fth multiple of corresponding kth

#row element*/

for j in range(k+ 1, N + 1): mat[i][j] mat[k][j]*f

#filling lower triangular matrix with zeros*/ mat[i][k]0

#print(mat); //for matrix state

#print(mat); return -1 //for matrix state

#function to calculate the values of the unknowns

def backSub(mat):

x [None for in range(N)] #An array to store solution

#Start calculating from last equation up to the

# first */

for i in range(N-1, -1, -1):

# start with the RHS of the equation */ x[i] = mat[i][N]

#Initialize j to i+1 since matrix is upper

# triangular*/

for j in range(1 + 1, N):

#subtract all the lhs values

#except the coefficient of the variable

#whose value is being calculated */ x[i] mat[i][j]*x[j]

#divide the RHS by the coefficient of the

#unknown being calculated

x[i]=(x[i]/mat[i][i])

print("\nSolution for the system:")

for i in range(N):

print("(:.8f}".format(x[i]))

#Driver program

#input matrix

mat [[1.0, 3.0, 2.0, 5.0], [2.0, 4.0, 6.0, 4.0], [1.0, 5, 3.0, 10.0]]

gaussianElimination(mat)
